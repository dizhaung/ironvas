package de.fhhannover.inform.trust.ironvas.omp

import java.util.logging.Logger

import scala.collection.JavaConversions.asJavaList

import de.fhhannover.inform.trust.ironvas.Report
import de.fhhannover.inform.trust.ironvas.VulnerabilityHandler

/**
 * A <code>VulnerabilityFetcher</code> is responsible for periodically getting
 * scan reports from on OpenVAS server.
 * 
 * @author Ralf Steuerwald
 * 
 * @constructor creates a new <code>VulnerabilityFetcher</code>
 * @param handler  the <code>VulnerabilityHandler</code> which is responsible
 *                 for processing the vulnerabilities
 * @param omp      the <code>OmpConnection</code> used for executing OMP requests
 * @param interval the time to wait between two fetch operations in seconds
 */
class VulnerabilityFetcher(
        handler: VulnerabilityHandler,
        omp: OmpConnection,
        interval: Int) extends Runnable {
    
    private val logger = Logger.getLogger(getClass().getName())
    
    /**
     * Run the fetch loop. The following steps are performed:
     * 
     * 1. Get the latest reports of all tasks from the OpenVAS server.
     * 2. For every latest report:
     *    2.1. Get all vulnerabilities of that report from the OpenVAS server.
     *    2.2. Send the list of vulnerabilities to the VulnerabilityHandler
     * 3. Sleep a given interval.
     * 4. Start at 1. again.
     */
    override def run(): Unit = {
        logger.info("starting " + getClass().getSimpleName())
        
        try {
	        while (!Thread.currentThread().isInterrupted()) {
	            val tasksWithLastReport = getTasksWithLastReport()
	            logger.fine("found " + tasksWithLastReport.length + " reports")
	
	            for (task <- tasksWithLastReport) {
	                val vulnerabilities = getVulnerabilities(task.lastReportId)
	                val javaList = asJavaList(vulnerabilities)
	                
	                val lastReport = new Report(task.id, javaList)
	                handler.submit(lastReport)
	            }
	            
	            Thread.sleep(interval * 1000)
	        }
        } catch {
            case e: InterruptedException => {
                Thread.currentThread().interrupt();
                logger.info("wakup by interrupt signal, exiting ...")
            }
        }
        finally {
            logger.info("shutdown complete.")
        }
    }
    
    private def getTasksWithLastReport() = {
        val (status, tasks) = omp.getTasks()
        val tasksWithLastReport = for ( task <- tasks
                if task.lastReportId.length() != 0) yield task
        tasksWithLastReport
    }
    
    private def getVulnerabilities(reportId: String) = {
        val (status, reports) = omp.getReports(reportId)
        reports.first
    }
    
    
}