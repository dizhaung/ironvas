/*
 * Project: ironvas
 * Package: main.java.de.fhhannover.inform.trust.ironvas
 * File:    VulnerabilityCache.java
 *
 * Copyright (C) 2011-2012 Fachhochschule Hannover
 * Ricklinger Stadtweg 118, 30459 Hannover, Germany 
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package de.fhhannover.inform.trust.ironvas;

import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;

/**
 * The {@link VulnerabilityCache} manages a set of {@link Vulnerability}
 * objects.
 * 
 * Each set of {@link Vulnerability} objects in the cache is associated with
 * a task id.
 * 
 * @author Ralf Steuerwald
 *
 */
public class VulnerabilityCache extends HashMap<String, Set<Vulnerability>> {
	
	/**
	 * Adds a set of {@link Vulnerability} objects to the cache. If the
	 * task id for the new set is not present in the cache it is also added.
	 * 
	 * @param taskId the task id from which the vulnerabilities are originated 
	 * @param x      the set of vulnerabilities to add
	 */
	public void addToTask(String taskId, Collection<Vulnerability> x) {
		if (containsKey(taskId)) {
			get(taskId).addAll(x);
		}
		else {
			Set<Vulnerability> news = new HashSet<Vulnerability>();
			news.addAll(x);
			put(taskId, news);
		}
	}
	
	/**
	 * Removes a set of vulnerabilities from the cache. If the task id is not
	 * contained in the cache nothing happens.
	 * 
	 * @param taskId the task from which the vulnerabilities will be removed
	 * @param x      the set of vulnerabilities to remove
	 */
	public void removeFromTask(String taskId, Collection<Vulnerability> x) {
		if (containsKey(taskId)) {
			get(taskId).removeAll(x);
		}
	}
	
	/**
	 * Returns a subset of vulnerabilities from x that may be out-dated.
	 * The set of out-dated vulnerabilities is calculated in the following
	 * manner: every object contained in the cache but not in x may be
	 * out-dated. 
	 * 
	 * Note: This method does NOT alter the cache content nor the content of x.
	 * 
	 * @param taskId
	 * @param x
	 * @return
	 */
	public Set<Vulnerability> indicateOutDated(String taskId,
			Collection<Vulnerability> x) {
		if (containsKey(taskId)) {
			// store the cache content in temp and remove all elements from x
			// (the most current ones) the remaining elements in temp may
			// be out-dated
			Set<Vulnerability> temp = new HashSet<Vulnerability>(get(taskId));
			temp.removeAll(x);
			return temp;
		}
		else {
			// no old vulnerabilities
			return new HashSet<Vulnerability>();
		}
		
	}
	
	/**
	 * Returns a subset of vulnerabilities from x which are not known in the
	 * cache.
	 * 
	 * Note: This method does NOT alter the cache content nor the content of x.
	 * 
	 * @param taskId
	 * @param x
	 * @return
	 */
	public Set<Vulnerability> indicateNew(String taskId,
			Collection<Vulnerability> x) {
		if (containsKey(taskId)) {
			// store the elements of x in temp and remove all elements
			// from temp which are stored in the cache, the remaining elements
			// are new
			Set<Vulnerability> temp = new HashSet<Vulnerability>(x);
			temp.removeAll(get(taskId));
			return temp;
		}
		else {
			// all vulnerabilities are new
			return new HashSet<Vulnerability>(x);
		}
	}
	
	public boolean contains(String taskId, Vulnerability v) {
		if (!containsKey(taskId)) {
			return false;
		}
		return get(taskId).contains(v);
	}
	
	public int vulnerabilityCount() {
		int count = 0;
		for (Collection<Vulnerability> c : values()) {
			count += c.size();
		}
		return count;
	}
	
}
