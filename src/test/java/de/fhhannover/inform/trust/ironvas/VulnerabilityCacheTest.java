/*
 * Project: ironvas
 * Package: de.fhhannover.inform.trust.ironvas
 * File:    VulnerabilityCacheTest.java
 *
 * Copyright (C) 2011-2012 Hochschule Hannover
 * Ricklinger Stadtweg 118, 30459 Hannover, Germany 
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package de.fhhannover.inform.trust.ironvas;

import java.util.HashSet;

import java.util.Set;

import org.junit.Before;
import org.junit.Test;

import de.fhhannover.inform.trust.ironvas.Vulnerability;
import de.fhhannover.inform.trust.ironvas.VulnerabilityCache;
import static org.mockito.Mockito.*;

import static org.junit.Assert.*;

public class VulnerabilityCacheTest {

	private final int count = 10;
	private Set<Vulnerability> cacheContent1;
	private Set<Vulnerability> cacheContent2;
	private Set<Vulnerability> cacheUpdateNoNew;
	private Set<Vulnerability> cacheUpdateAllNew;
	private Set<Vulnerability> cacheUpdateMixed;
	private VulnerabilityCache cache;
	private final String taskId1 = "ff0ab0bd-cf25-4bd1-a2f3-40194c91b7cf";
	private final String taskId2 = "bb1bb1bb-cf25-4bd1-a2f3-42222c91aaaf";
	
	private Vulnerability mockVulnerabily(int id) {
		Vulnerability v = mock(Vulnerability.class);
		when(v.getId()).thenReturn(id + "");
		return v;
	}
	
	@Before
	public void setUp() {
		cacheContent1 = new HashSet<Vulnerability>();
		cacheContent2 = new HashSet<Vulnerability>();
		cacheUpdateNoNew = new HashSet<Vulnerability>();
		cacheUpdateAllNew = new HashSet<Vulnerability>();
		cacheUpdateMixed = new HashSet<Vulnerability>();
		
		for (int i = 0; i < count; i++) {
			Vulnerability v = mockVulnerabily(i);
			cacheContent1.add(v);
			cacheContent2.add(v);
			
			if (i < count / 2) {
				cacheUpdateNoNew.add(v);
			}
			if (i % 2 == 0) {
				cacheUpdateMixed.add(v);
			}
		}
		
		for (int i = 0; i < count; i++) {
			Vulnerability v = mockVulnerabily(i + 100);
			cacheUpdateAllNew.add(v);
			
			if (i % 2 == 1) {
				cacheUpdateMixed.add(v);
			}
		}
		
		cache = new VulnerabilityCache();
		cache.addToTask(taskId1, cacheContent1);
	}
	
	@Test
	public void testIndicateOutDatedUpdateNoNew() {
		Set<Vulnerability> noneCurrent =
				cache.indicateOutDated(taskId1, cacheUpdateNoNew);

		assertEquals(cacheContent1.size() - cacheUpdateNoNew.size(),
				noneCurrent.size());
		assertFalse(noneCurrent.equals(cacheUpdateNoNew));
	}
	
	@Test
	public void testIndicateOutDatedAllNew() {
		Set<Vulnerability> noneCurrent =
				cache.indicateOutDated(taskId1, cacheUpdateAllNew);
		
		assertEquals(cache.get(taskId1).size(), noneCurrent.size());
		assertEquals(cache.get(taskId1), noneCurrent);
	}
	
	@Test
	public void testIndicateOutDatedMixed() {
		Set<Vulnerability> noneCurrent =
				cache.indicateOutDated(taskId1, cacheUpdateMixed);
		
		assertEquals(cache.get(taskId1).size() / 2, noneCurrent.size());
		for (Vulnerability v : noneCurrent) {
			assertTrue(cache.contains(taskId1, v));
		}
	}

	@Test
	public void testIndicateNewAllNew() {
		Set<Vulnerability> news = cache.indicateNew(taskId1, cacheUpdateAllNew);
		
		assertEquals(cacheUpdateAllNew.size(), news.size());
		assertEquals(cacheUpdateAllNew, news);
	}
	
	@Test
	public void testIndicateNewNoNew() {
		Set<Vulnerability> news = cache.indicateNew(taskId1, cacheUpdateNoNew);
		assertEquals(0, news.size());
	}
	
	@Test
	public void testIndicateNewMixed() {
		Set<Vulnerability> news = cache.indicateNew(taskId1, cacheUpdateMixed);
		
		assertEquals(cache.get(taskId1).size() / 2, news.size());
		for (Vulnerability v : news) {
			assertFalse(cache.contains(taskId1, v));
		}
	}
	
	@Test
	public void testAddToTask() {
		int before = cache.vulnerabilityCount();
		cache.addToTask(taskId2, cacheContent2);
		assertEquals(before + cacheContent2.size(), cache.vulnerabilityCount());
		for (Vulnerability v: cacheContent2) {
			assertTrue(cache.contains(taskId2, v));
		}
	}
	
	@Test
	public void testRemoveFromTask() {
		int before = cache.vulnerabilityCount();
		cache.removeFromTask(taskId1, cacheUpdateNoNew);
		assertEquals(before - cacheUpdateNoNew.size(), cache.vulnerabilityCount());
		for (Vulnerability v: cacheUpdateNoNew) {
			assertFalse(cache.contains(taskId2, v));
		}
	}
	
	@Test
	public void testContains() {
		for (Vulnerability v : cacheContent1) {
			assertTrue(cache.contains(taskId1, v));
			assertFalse(cache.contains(taskId2, v));
		}
	}
	
	@Test
	public void testVulnerabilityCount() {
		assertEquals(cacheContent1.size(), cache.vulnerabilityCount());
		cache.addToTask(taskId2, cacheContent2);
		assertEquals(cacheContent1.size() + cacheContent2.size(), cache.vulnerabilityCount());
	}
	
}
